/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Serial.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Serial
 #	author : miyako
 #	2022/02/04
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Serial.h"

ORSSerialPortObserver *serialPortObserver = nil;

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 59

std::mutex globalMutex; /* for context management */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

namespace SERIAL
{
    //constants
    process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0S\0E\0R\0I\0A\0L\0\0\0";
    process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;

    //context management
    NSMutableArray<NSData *>*SERIAL_DATA;
    NSMutableArray<NSString *>*SERIAL_PATH;

    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;
}

@implementation ORSSerialPortObserver

- (id)init
{
    if(!(self = [super init])) return self;
    
    [[NSNotificationCenter defaultCenter]
     addObserver:self
     selector:@selector(serialPortsWereConnected:)
     name:ORSSerialPortsWereConnectedNotification
     object:nil];
    
    [[NSNotificationCenter defaultCenter]
     addObserver:self
     selector:@selector(serialPortsWereDisconnected:)
     name:ORSSerialPortsWereDisconnectedNotification
     object:nil];
    
    NSArray *availablePorts = [[ORSSerialPortManager sharedSerialPortManager]availablePorts];
    
    for(NSUInteger i = 0; i < [availablePorts count];++i)
    {
        ORSSerialPort *port = [availablePorts objectAtIndex:i];
        ORSSerialPortHelper *serialPortDelegate = [[ORSSerialPortHelper alloc]init];
        port.delegate = serialPortDelegate;
    }
    
    return self;
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter]removeObserver:self];
        
    [super dealloc];
}

- (void)serialPortsWereConnected:(NSNotification *)notification
{
    NSArray *connectedPorts = [notification userInfo][ORSConnectedSerialPortsKey];
    
    NSLog(@"Ports were connected: %@", connectedPorts);
    
    for(NSUInteger i = 0; i < [connectedPorts count];++i)
    {
        ORSSerialPort *port = [connectedPorts objectAtIndex:i];
        if(port.delegate)
        {
            [port.delegate release];
        }
        port.delegate = [[ORSSerialPortHelper alloc]init];
    }
}

- (void)serialPortsWereDisconnected:(NSNotification *)notification
{
    NSArray *disconnectedPorts = [notification userInfo][ORSDisconnectedSerialPortsKey];
    
    NSLog(@"Ports were disconnected: %@", disconnectedPorts);
    
    for(NSUInteger i = 0; i < [disconnectedPorts count];++i)
    {
        ORSSerialPort *port = [disconnectedPorts objectAtIndex:i];
        if(port.delegate)
        {
            [port.delegate release];
            port.delegate = nil;
        }
    }
}
@end

@implementation ORSSerialPortHelper

- (void)serialPort:(ORSSerialPort *)serialPort didReceiveData:(NSData *)data
{
    [SERIAL::SERIAL_PATH addObject:[serialPort path]];
    [SERIAL::SERIAL_DATA addObject:data];
    listenerLoopExecute();
}

- (void)serialPortWasRemovedFromSystem:(ORSSerialPort *)serialPort
{
    /* serialPortsWereDisconnected follows */
}

- (void)serialPortWasOpened:(ORSSerialPort *)serialPort
{
    NSLog(@"port opened:%@", [serialPort path]);
}

- (void)serialPortWasClosed:(ORSSerialPort *)serialPort
{
    NSLog(@"port closed:%@", [serialPort path]);
}

- (void)serialPort:(ORSSerialPort *)serialPort didEncounterError:(NSError *)error
{
    NSLog(@"%s %@ %@", __PRETTY_FUNCTION__, serialPort, error);
}

@end

bool IsProcessOnExit()
{
    PA_long32 state, time;
    
    std::vector<PA_Unichar>buf(33);
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), &buf[0], &state, &time);
    CUTF16String procName(&buf[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

static void listener_start() {
    
    if(!serialPortObserver)
    {
        SERIAL::SERIAL_PATH = [[NSMutableArray alloc]init];
        SERIAL::SERIAL_DATA = [[NSMutableArray alloc]init];
        
        serialPortObserver = [[ORSSerialPortObserver alloc]init];
    }

}

static void listener_end() {
    
    if(IsProcessOnExit())
    {
        if(serialPortObserver)
        {
            [SERIAL::SERIAL_PATH release];
            [SERIAL::SERIAL_DATA release];
            
            [serialPortObserver release];
            serialPortObserver = nil;
        }
    }

}

static void generateUuid(C_TEXT &returnValue) {
    
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
}

void listenerLoop() {
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        SERIAL::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = SERIAL::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = SERIAL::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t SERIAL_PATHS;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                SERIAL_PATHS = [SERIAL::SERIAL_PATH count];
            }
            
            while(SERIAL_PATHS)
            {
                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  SERIAL::MONITOR_PROCESS_STACK_SIZE,
                                  (PA_Unichar *)processName.getUTF16StringPtr());
                }else
                {
                     listenerLoopExecuteMethod();
                }
                
                if(PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    SERIAL_PATHS = [SERIAL::SERIAL_PATH count];
                    PROCESS_SHOULD_TERMINATE = SERIAL::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                SERIAL::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = SERIAL::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_TERMINATE)
            break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        [SERIAL::SERIAL_PATH removeAllObjects];
        [SERIAL::SERIAL_DATA removeAllObjects];
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        SERIAL::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        SERIAL::METHOD_PROCESS_ID = 0;
    }
    
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);

    PA_KillProcess();
}

void listenerLoopStart() {
    
    if(!SERIAL::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        SERIAL::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                              SERIAL::MONITOR_PROCESS_STACK_SIZE,
                                              SERIAL::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish() {
    
    if(SERIAL::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            SERIAL::PROCESS_SHOULD_TERMINATE = true;
        }
        
        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);

            SERIAL::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute() {
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        SERIAL::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        SERIAL::PROCESS_SHOULD_RESUME = true;
    }

}

void listenerLoopExecuteMethod() {
    
    NSString *path = [SERIAL::SERIAL_PATH objectAtIndex:0];
    NSData *data = [SERIAL::SERIAL_DATA objectAtIndex:0];
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)SERIAL::LISTENER_METHOD.getUTF16StringPtr());
    
    if(methodId)
    {
        PA_Variable    params[2];
        params[0] = PA_CreateVariable(eVK_Unistring);
        params[1] = PA_CreateVariable(eVK_Blob);

        C_TEXT _path;
        _path.setUTF16String(path);
        PA_SetUnistring((&(params[0].uValue.fString)),
                                        (PA_Unichar *)_path.getUTF16StringPtr());
        
        PA_SetBlobVariable(&params[1], (void *)[data bytes], [data length]);
        
        PA_ExecuteMethodByID(methodId, params, 2);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);

    }else{
        
        PA_Variable    params[3];
        
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)SERIAL::LISTENER_METHOD.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &method);
        
        params[1] = PA_CreateVariable(eVK_Unistring);
        params[2] = PA_CreateVariable(eVK_Blob);

        C_TEXT _path;
        _path.setUTF16String(path);
        PA_SetUnistring((&(params[1].uValue.fString)),
                                        (PA_Unichar *)_path.getUTF16StringPtr());
        
        PA_SetBlobVariable(&params[2], (void *)[data bytes], [data length]);
        
        PA_ExecuteCommandByID(1007, params, 3);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
    }
    
    [SERIAL::SERIAL_PATH removeObjectAtIndex:0];
    [SERIAL::SERIAL_DATA removeObjectAtIndex:0];
}

static void OnStartup()
{

}

static void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        listenerLoopFinish();
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kCloseProcess :
                OnCloseProcess();
                break;
                
			// --- Serial
            
			case 1 :
				SERIAL_GET_AVAILABLE_PORTS(params);
				break;
			case 2 :
				SERIAL_OPEN_PATH(params);
				break;
			case 3 :
				SERIAL_CLOSE_PATH(params);
				break;
			case 4 :
				SERIAL_SEND_DATA(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static PA_ObjectRef getPort(ORSSerialPort *port) {
    
    PA_ObjectRef o = PA_CreateObject();
    
    if(port) {
        ob_set_s(o, L"path", [[port path]UTF8String]);
        ob_set_b(o, L"isOpen", [port isOpen]);
        ob_set_s(o, L"name", [[port name]UTF8String]);
        ob_set_n(o, L"baudRate", [[port baudRate]intValue]);
        ob_set_b(o, L"allowsNonStandardBaudRates", [port allowsNonStandardBaudRates]);
        ob_set_n(o, L"numberOfStopBits", [port numberOfStopBits]);
        
        switch ([port parity]) {
            case ORSSerialPortParityNone:
                ob_set_s(o, L"parity", "none");
                break;
            case ORSSerialPortParityOdd:
                ob_set_s(o, L"parity", "odd");
                break;
            case ORSSerialPortParityEven:
                ob_set_s(o, L"parity", "even");
                break;
        }

        ob_set_b(o, L"shouldEchoReceivedData", [port shouldEchoReceivedData]);
        ob_set_b(o, L"usesRTSCTSFlowControl", [port usesRTSCTSFlowControl]);
        ob_set_b(o, L"usesDTRDSRFlowControl", [port usesDTRDSRFlowControl]);
        ob_set_b(o, L"usesDCDOutputFlowControl", [port usesDCDOutputFlowControl]);
        
        ob_set_b(o, L"RTS", [port RTS]);
        ob_set_b(o, L"DTR", [port DTR]);
        ob_set_b(o, L"CTS", [port CTS]);
        ob_set_b(o, L"DSR", [port DSR]);
        ob_set_b(o, L"DCD", [port DCD]);
    }
        
    return  o;
}

void SERIAL_GET_AVAILABLE_PORTS(PA_PluginParameters params) {

    PA_CollectionRef ports = PA_CreateCollection();
    
    NSArray *availablePorts = [[ORSSerialPortManager sharedSerialPortManager]availablePorts];
    
    for(NSUInteger i = 0; i < [availablePorts count];++i)
    {
        ORSSerialPort *port = [availablePorts objectAtIndex:i];
        
        PA_ObjectRef o = getPort(port);

        PA_Variable v = PA_CreateVariable(eVK_Object);
        PA_SetObjectVariable(&v, o);
        PA_SetCollectionElement(ports, PA_GetCollectionLength(ports), v);
    }
    
    PA_ReturnCollection(params, ports);
}

void SERIAL_OPEN_PATH(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;

    PA_ObjectRef status = PA_CreateObject();
    
    bool success = false;
    
    if(!IsProcessOnExit())
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex2);
            
            SERIAL::LISTENER_METHOD.fromParamAtIndex(pParams, 3);
        }
        
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);

        listenerLoopStart();
        
    }
    
    C_TEXT Param1_path;
    Param1_path.fromParamAtIndex(pParams, 1);
        
    NSString *path = Param1_path.copyUTF16String();

    ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
    if((port) && (!port.isOpen))
    {
        PA_ObjectRef options = PA_GetObjectParameter(params, 2);
        
        if(options) {
            
            if(ob_is_defined(options, L"usesRTSCTSFlowControl")) {
                port.usesRTSCTSFlowControl = ob_get_b(options, L"usesRTSCTSFlowControl");
            }
            if(ob_is_defined(options, L"usesDTRDSRFlowControl")) {
                port.usesDTRDSRFlowControl = ob_get_b(options, L"usesDTRDSRFlowControl");
            }
            if(ob_is_defined(options, L"usesDCDOutputFlowControl")) {
                port.usesDCDOutputFlowControl = ob_get_b(options, L"usesDCDOutputFlowControl");
            }
            if(ob_is_defined(options, L"shouldEchoReceivedData")) {
                port.shouldEchoReceivedData = ob_get_b(options, L"shouldEchoReceivedData");
            }
            if(ob_is_defined(options, L"RTS")) {
                port.RTS = ob_get_b(options, L"RTS");
            }
            if(ob_is_defined(options, L"DTR")) {
                port.DTR = ob_get_b(options, L"DTR");
            }
            if(ob_is_defined(options, L"baudRate")) {
                port.baudRate = [NSNumber numberWithInt:ob_get_n(options, L"baudRate")];
            }
            if(ob_is_defined(options, L"numberOfStopBits")) {
                port.numberOfStopBits = ob_get_n(options, L"numberOfStopBits");
            }
            CUTF8String stringValue;
            if(ob_get_s(options, L"parity", &stringValue)) {
                if(stringValue == (const uint8_t *)"none") {
                    port.parity = ORSSerialPortParityNone;
                }
                if(stringValue == (const uint8_t *)"odd") {
                    port.parity = ORSSerialPortParityOdd;
                }
                if(stringValue == (const uint8_t *)"even") {
                    port.parity = ORSSerialPortParityEven;
                }
                
            }
            
        }
                
        [port open];
        
        success = [port isOpen];
        
        PA_ObjectRef o = getPort(port);
        ob_set_o(status, L"port", o);
        
    }/* port */

    [path release];
    
    ob_set_b(status, L"success", success);
    PA_ReturnObject(params, status);
}

void SERIAL_CLOSE_PATH(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    
    bool success = false;
    
    C_TEXT Param1_path;

    Param1_path.fromParamAtIndex(pParams, 1);

    NSString *path = Param1_path.copyUTF16String();
    ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
    if((port) && (port.isOpen))
    {
        success = [port close];
        
        PA_ObjectRef o = getPort(port);
        ob_set_o(status, L"port", o);
    }
    
    [path release];
    
    ob_set_b(status, L"success", success);
    PA_ReturnObject(params, status);
}

void SERIAL_SEND_DATA(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_TEXT Param1_path;
    
    Param1_path.fromParamAtIndex(pParams, 1);

    NSString *path = Param1_path.copyUTF16String();
    ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
    if((port) && (port.isOpen))
    {
        PA_Handle h = *(PA_Handle *)(pParams[1]);
        
        if(h)
        {
            NSData *data = [[NSData alloc]initWithBytes:PA_LockHandle(h) length:PA_GetHandleSize(h)];
            [port sendData:data];
            [data release];
            PA_UnlockHandle(h);
        }

    }
    [path release];
}
