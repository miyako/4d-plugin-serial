/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Serial
 #	author : miyako
 #	2017/11/10
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

ORSSerialPortObserver *serialPortObserver = nil;

#pragma mark Listener

void listenerLoop()
{
	serialPortObserver.monitorProcessId = PA_GetCurrentProcessNumber();
	NSLock *l = [[NSLock alloc]init];
	NSLog(@"%@", @"listenerLoop:start");
	while((serialPortObserver) && !PA_IsProcessDying())
	{
		PA_FreezeProcess(PA_GetCurrentProcessNumber());
		PA_YieldAbsolute();
		
		if ([l tryLock])
		{
			if(serialPortObserver)
			{
				if(serialPortObserver.length)
				{
					[serialPortObserver call4D];
				}
			}
			[l unlock];
		}
	}
	NSLog(@"%@", @"listenerLoop:end");
	PA_KillProcess();
	[l release];
}

#pragma mark Main

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			// --- Serial

		case 1 :
			SERIAL_GET_AVAILABLE_PORTS(pResult, pParams);
			break;

		case 2 :
			SERIAL_OPEN_PATH(pResult, pParams);
			break;

		case 3 :
			SERIAL_CLOSE_PATH(pResult, pParams);
			break;

		case 4 :
			SERIAL_SEND_DATA(pResult, pParams);
			break;

	}
}

// ------------------------------------ Serial ------------------------------------

#pragma mark JSON

void json_wconv(const char *value, std::wstring &u32)
{
	if((value) && strlen(value))
	{
		C_TEXT t;
		CUTF8String u8 = CUTF8String((const uint8_t *)value);
		
		t.setUTF8String(&u8);
		
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
	}else
	{
		u32 = L"";
	}
	
}

void json_wconv(NSString *value, std::wstring &u32)
{
	if(value)
	{
		C_TEXT t;
		CUTF8String u8;
		
		t.setUTF16String(value);
		
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
		
	}else
	{
		u32 = L"";
	}
	
}

void json_set_i(JSONNODE *n, json_char *key, int value)
{
	if(n)
	{
		JSONNODE *e = json_get(n, key);
		if(e)
		{
			json_set_b(e, value);//over-write existing value
		}else
		{
			json_push_back(n, json_new_i(key, value));
		}
	}
}

void json_set_b(JSONNODE *n, json_char *key, BOOL value)
{
	if(n)
	{
		JSONNODE *e = json_get(n, key);
		if(e)
		{
			json_set_b(e, value);//over-write existing value
		}else
		{
			json_push_back(n, json_new_b(key, value));
		}
	}
}

void json_set_s(JSONNODE *n, json_char *key, NSString *value)
{
	if(n)
	{
		if(value)
		{
			std::wstring w32;
			json_wconv(value, w32);
			
			JSONNODE *e = json_get(n, key);
			if(e)
			{
				json_set_a(e, w32.c_str());//over-write existing value
			}else
			{
				json_push_back(n, json_new_a(key, w32.c_str()));
			}
			
		}else
		{
			JSONNODE *e = json_get(n, key);
			if(e)
			{
				json_nullify(e);//over-write existing value
			}else
			{
				JSONNODE *node = json_new_a(key, L"");
				json_nullify(node);
				json_push_back(n, node);
			}
		}
	}
}

void json_stringify(JSONNODE *json, ARRAY_TEXT& param, BOOL pretty)
{
	json_char *json_string = pretty ? json_write_formatted(json) : json_write(json);
	std::wstring wstr = std::wstring(json_string);
	uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																						(PA_long32)(wstr.length() * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	param.setUTF16StringAtIndex((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar), 0);
	json_free(json_string);
}

#pragma mark ORSSerialPortDelegate

@implementation ORSSerialPortHelper

- (void)serialPort:(ORSSerialPort *)serialPort didReceiveData:(NSData *)data
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		[serialPortObserver appendData:data
														method:self.callbackMethodName
													 context:self.callbackMethodContext
															path:serialPort.path];
		
		PA_UnfreezeProcess(serialPortObserver.monitorProcessId);
		
		[l unlock];
	}
	[l release];
}

- (void)serialPortWasRemovedFromSystem:(ORSSerialPort *)serialPort
{
	/* serialPortsWereDisconnected follows */
}

- (void)serialPortWasOpened:(ORSSerialPort *)serialPort
{
	NSLog(@"port opened:%@", [serialPort path]);
}

- (void)serialPortWasClosed:(ORSSerialPort *)serialPort
{
	NSLog(@"port closed:%@", [serialPort path]);
}

- (void)serialPort:(ORSSerialPort *)serialPort didEncounterError:(NSError *)error
{
	NSLog(@"%s %@ %@", __PRETTY_FUNCTION__, serialPort, error);
}

@end

#pragma mark NSNotification

NSArray *availablePorts;
static void *ORSSerialPortAvailablePortsContext = &ORSSerialPortAvailablePortsContext;

@implementation ORSSerialPortObserver

- (id)init
{
	if(!(self = [super init])) return self;
	
	[[NSNotificationCenter defaultCenter]
	 addObserver:self
	 selector:@selector(serialPortsWereConnected:)
	 name:ORSSerialPortsWereConnectedNotification
	 object:nil];
	
	[[NSNotificationCenter defaultCenter]
	 addObserver:self
	 selector:@selector(serialPortsWereDisconnected:)
	 name:ORSSerialPortsWereDisconnectedNotification
	 object:nil];
	
	data_array = [[NSMutableArray alloc]init];
	method_array = [[NSMutableArray alloc]init];
	context_array = [[NSMutableArray alloc]init];
	path_array = [[NSMutableArray alloc]init];
	
	NSArray *availablePorts = [[ORSSerialPortManager sharedSerialPortManager]availablePorts];
	
	for(NSUInteger i = 0; i < [availablePorts count];++i)
	{
		ORSSerialPort *port = [availablePorts objectAtIndex:i];
		ORSSerialPortHelper *serialPortDelegate = [[ORSSerialPortHelper alloc]init];
		port.delegate = serialPortDelegate;
	}
	
	return self;
}

- (void)start
{
	self.monitorProcessId = PA_NewProcess((void *)listenerLoop,
																				self.stackSize,
																				(PA_Unichar *)"$\0S\0E\0R\0I\0A\0L\0_\0P\0O\0R\0T\0\0\0");
}

- (void)dealloc
{
	[[NSNotificationCenter defaultCenter]removeObserver:self];
	
	[data_array release];
	[method_array release];
	[context_array release];
	[path_array release];
	
	PA_UnfreezeProcess(self.monitorProcessId);
	
	[super dealloc];
}

- (NSUInteger)length
{
	return [data_array count];
}

- (NSUInteger)stackSize
{
	return 0;
}

- (void)call4D
{
	if([data_array count])
	{
		NSData *data = [data_array objectAtIndex:0];
		NSString *method = [method_array objectAtIndex:0];
		NSString *context = [context_array objectAtIndex:0];
		NSString *path = [path_array objectAtIndex:0];
		
		NSLock *l = [[NSLock alloc]init];
		
		if ([l tryLock])
		{
			C_TEXT p1, p2;
			p1.setUTF16String(method);
			method_id_t methodId = PA_GetMethodID((PA_Unichar *)p1.getUTF16StringPtr());
			
			if(methodId)
			{
				PA_Variable	params[3];
				params[0] = PA_CreateVariable(eVK_Unistring);
				params[1] = PA_CreateVariable(eVK_Blob);
				params[2] = PA_CreateVariable(eVK_Unistring);
				
				p1.setUTF16String(path);
				PA_SetUnistring((&(params[0].uValue.fString)),
												(PA_Unichar *)p1.getUTF16StringPtr());
				
				PA_SetBlobVariable(&params[1], (void *)[data bytes], [data length]);
				
				p2.setUTF16String(context);
				PA_SetUnistring((&(params[2].uValue.fString)),
												(PA_Unichar *)p2.getUTF16StringPtr());
				
				PA_ExecuteMethodByID(methodId, params, 3);
				
				PA_ClearVariable(&params[0]);
				PA_ClearVariable(&params[1]);
				PA_ClearVariable(&params[2]);
			}/* methodId */
			[l unlock];
		}
		
		[l release];
		
		[data_array removeObjectAtIndex:0];
		[method_array removeObjectAtIndex:0];
		[context_array removeObjectAtIndex:0];
		[path_array removeObjectAtIndex:0];
		
	}/* [data_array count] */
	
}

- (void)appendData:(NSData *)data method:(NSString *)method context:(NSString *)context path:(NSString *)path
{
	[data_array addObject:data];
	[method_array addObject:method];
	[context_array addObject:context];
	[path_array addObject:path];
}

#pragma mark -

- (void)serialPortsWereConnected:(NSNotification *)notification
{
	NSArray *connectedPorts = [notification userInfo][ORSConnectedSerialPortsKey];
	NSLog(@"Ports were connected: %@", connectedPorts);
	
	for(NSUInteger i = 0; i < [connectedPorts count];++i)
	{
		ORSSerialPort *port = [connectedPorts objectAtIndex:i];
		if(port.delegate)
		{
			[port.delegate release];
		}
		port.delegate = [[ORSSerialPortHelper alloc]init];
	}
}

- (void)serialPortsWereDisconnected:(NSNotification *)notification
{
	NSArray *disconnectedPorts = [notification userInfo][ORSDisconnectedSerialPortsKey];
	NSLog(@"Ports were disconnected: %@", disconnectedPorts);
	
	for(NSUInteger i = 0; i < [disconnectedPorts count];++i)
	{
		ORSSerialPort *port = [disconnectedPorts objectAtIndex:i];
		if(port.delegate)
		{
			[port.delegate release];
			port.delegate = nil;
		}
	}
}
@end

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	serialPortObserver = [[ORSSerialPortObserver alloc]init];
	[serialPortObserver start];
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		if(serialPortObserver)
		{
			[serialPortObserver release];
			serialPortObserver = nil;
		}
	}
}

#pragma mark -

JSONNODE *json_from_port(ORSSerialPort *port)
{
	JSONNODE *json_item = json_new(JSON_NODE);
	json_set_s(json_item, L"name", [port name]);
	json_set_s(json_item, L"path", [port path]);
	json_set_b(json_item, L"RTS", [port RTS]);
	json_set_b(json_item, L"DTR", [port DTR]);
	json_set_b(json_item, L"CTS", [port CTS]);
	json_set_b(json_item, L"DSR", [port DSR]);
	json_set_b(json_item, L"DCD", [port DCD]);
	json_set_b(json_item, L"isOpen", [port isOpen]);
	json_set_i(json_item, L"baudRate", [[port baudRate]intValue]);
	json_set_i(json_item, L"numberOfStopBits", [port numberOfStopBits]);
	json_set_i(json_item, L"parity", [port parity]);
	json_set_b(json_item, L"usesRTSCTSFlowControl", [port usesRTSCTSFlowControl]);
	json_set_b(json_item, L"usesDTRDSRFlowControl", [port usesDTRDSRFlowControl]);
	json_set_b(json_item, L"usesDCDOutputFlowControl", [port usesDCDOutputFlowControl]);
	json_set_b(json_item, L"shouldEchoReceivedData", [port shouldEchoReceivedData]);
	
	return json_item;
}

void json_append_port(JSONNODE *json, ORSSerialPort *port)
{
	json_push_back(json, json_from_port(port));
}

void json_set_port_option(JSONNODE *n, ORSSerialPort *port)
{
	json_char *name = json_name(n);
	
	if (name)
	{
		std::wstring s = std::wstring((const wchar_t *)name);
		
		if (s.compare(L"usesRTSCTSFlowControl") == 0)
		{
			port.usesRTSCTSFlowControl = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"usesDTRDSRFlowControl") == 0)
		{
			port.usesDTRDSRFlowControl = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"usesDCDOutputFlowControl") == 0)
		{
			port.usesDCDOutputFlowControl = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"shouldEchoReceivedData") == 0)
		{
			port.shouldEchoReceivedData = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"RTS") == 0)
		{
			port.RTS = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"DTR") == 0)
		{
			port.DTR = json_as_bool(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"baudRate") == 0)
		{
			port.baudRate = [NSNumber numberWithInt:json_as_int(n)];
			goto json_set_port_option_exit;
		}
		if (s.compare(L"numberOfStopBits") == 0)
		{
			port.numberOfStopBits = json_as_int(n);
			goto json_set_port_option_exit;
		}
		if (s.compare(L"parity") == 0)
		{
			port.parity = json_as_int(n);
			goto json_set_port_option_exit;
		}
		
	json_set_port_option_exit:
		json_free(name);
	}

}

#pragma mark -

void SERIAL_GET_AVAILABLE_PORTS(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1_paths;
	
	Param1_paths.setSize(1);
	JSONNODE *json = json_new(JSON_ARRAY);
	
	NSArray *availablePorts = [[ORSSerialPortManager sharedSerialPortManager]availablePorts];
	
	for(NSUInteger i = 0; i < [availablePorts count];++i)
	{
		ORSSerialPort *port = [availablePorts objectAtIndex:i];
		Param1_paths.appendUTF16String([port path]);
		json_append_port(json, port);
	}
	
	json_stringify(json, Param1_paths, FALSE);
	json_delete(json);
	
	Param1_paths.toParamAtIndex(pParams, 1);
}

void SERIAL_OPEN_PATH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_path;
	C_TEXT Param2_options;
	C_TEXT Param3_method;
	C_TEXT Param4_context;
	
	Param1_path.fromParamAtIndex(pParams, 1);
	Param2_options.fromParamAtIndex(pParams, 2);
	Param3_method.fromParamAtIndex(pParams, 3);
	Param4_context.fromParamAtIndex(pParams, 4);

	NSString *path = Param1_path.copyUTF16String();
	NSString *method = Param3_method.copyUTF16String();
	NSString *context = Param4_context.copyUTF16String();
	
	ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
	if((port) && (!port.isOpen))
	{
		CUTF8String Param2_u8;
		Param2_options.copyUTF8String(&Param2_u8);
		std::wstring options;
		json_wconv((const char *)Param2_u8.c_str(), options);
		JSONNODE *option = json_parse(options.c_str());
		if(option)
		{
			if (json_type(option) == JSON_NODE)
			{
				JSONNODE_ITERATOR i = json_begin(option);
				while (i != json_end(option))
				{
					json_set_port_option(*i, port);
					++i;
				}
			}
			json_delete(option);
		}
		
		ORSSerialPortHelper *delegate = port.delegate;
		
		if(delegate)
		{
			delegate.callbackMethodName = method;
			delegate.callbackMethodContext = context;
		}
		
		[port open];
		
	}/* port */
	
	[context release];
	[method release];
	[path release];
}

void SERIAL_CLOSE_PATH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_path;

	Param1_path.fromParamAtIndex(pParams, 1);

	NSString *path = Param1_path.copyUTF16String();
	ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
	if((port) && (port.isOpen))
	{
		[port close];
	}
	
	[path release];
}

void SERIAL_SEND_DATA(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_path;

	Param1_path.fromParamAtIndex(pParams, 1);

	NSString *path = Param1_path.copyUTF16String();
	ORSSerialPort *port = [ORSSerialPort serialPortWithPath:path];
	if((port) && (port.isOpen))
	{
		PA_Handle h = *(PA_Handle *)(pParams[1]);
		
		if(h)
		{
			NSData *data = [[NSData alloc]initWithBytes:PA_LockHandle(h) length:PA_GetHandleSize(h)];
			[port sendData:data];
			[data release];
			PA_UnlockHandle(h);
		}

	}
	[path release];
}

